## Лабораторная работа №5: Отладĸа ĸодовой базы проеĸта на Python с помощью средств отладĸи

### Ошибка 1 — ошибка границы цикла (off-by-one)

**Место:** `simulation.py`, функция `simulate_remove_book`

**Симптом:**
Программа падает с `IndexError: list index out of range` при попытке удалить книгу

**Как воспроизвести:** 
```bash
python main.py 33
```

**Отладка:**
Установлен breakpoint на строке 62. В отладчике видно, что `book_index = len(library.books)`, что выходит за границы списка `[0, len(library.books)-1]`

**Причина:**
`random.randint(a, len(library.books))` включает оба конца диапазона, поэтому может вернуть `len(library.books)`, который не является допустимым индексом

**Исправление:**
```python
# Было (ошибка):
book_index = random.randint(0, len(library.books))

# Стало (исправлено):
book_index = random.randint(0, len(library.books) - 1)
```

**Проверка:** 
Поведение симуляции соответствует ожидаемому.

**Доказательства:**

![img_1.png](Снимок%20экрана%202025-12-14%20220019.png)
![img_2.png](Снимок%20экрана%202025-12-14%20220908.png)

---

### Ошибка 2 — использование изменяемого значения по умолчанию

**Место:** `classes.py`, класс `BookCollection`, метод `__init__`

**Симптом:**
Поиск по автору или жанру возвращает книги, не принадлежащие запрошенному автору/жанру

**Как воспроизвести:**
Запустить симуляцию и дождаться действия поиска по автору/жанру/году. В результатах будут книги разных жанров.

**Отладка:**
Установлен breakpoint на строке 150 в `BookCollection.__init__`.

**За первый вызов инициализируем список:**
```python
books = []
id(books) = 2248300597568
```

**Второй вызов создание коллекции для какого-нибудь автора:**
```python
books = []
id(books) = 2248300597568
```

**Третий вызов коллекция для другого автора:**
```python
books = [Book("Война и мир"...),...] 
id(books) = 2248300597568
```

**Причина:**
Параметр `books` имеет изменяемое значение по умолчанию `[]`. Значение по умолчанию вычисляется один раз при загрузке модуля. Все вызовы `BookCollection()` без аргументов получают ссылку на один и тот же объект списка в памяти.

**Исправление:**
```python
# Было:
def __init__(self, books: list[Book] = []):
    self._books: list[Book] = books

# Стало:
def __init__(self):
    self._books: list[Book] = []
```

**Проверка:**
Поведение симуляции соответствует ожидаемому.

**Доказательства:**
![img_1.png](Снимок%20экрана%202025-12-16%20104455.png)
![img_2.png](Снимок%20экрана%202025-12-16%20132040.png)
![img_3.png](Снимок%20экрана%202025-12-16%20132234.png)

---

### Ошибка 3 — неверное логическое условие

**Место:** `classes.py`, класс `BookCollection`, метод `add`

**Симптом:**
Библиотека остается пустой на протяжении всей симуляции. В логах отсутствуют сообщения "Добавлена книга"

**Как воспроизвести:**
```bash
python main.py 20 123
```

**Отладка:**
Установлен breakpoint на строке `if book not in self._books`.
При попытке добавить первую книгу:
```python
self._books = []
book in self._books = False 
book not in self._books = True
```
Библиотека остается пустой.

**Причина:**
Использовано инвертированное логическое условие `book not in self._books` вместо `book in self._books`. Программа считает, что книга уже есть в коллекции, и блокирует добавление любой новой книги.

**Исправление:**
```python
# Было:
if book not in self._books:
    raise ValueError("Такая книга уже есть в коллекции")

# Стало:
if book in self._books:
    raise ValueError("Такая книга уже есть в коллекции")
```

**Проверка:**
Поведение симуляции соответствует ожидаемому.

**Доказательства:**
![img_1.png](Снимок%20экрана%202025-12-16%20155215.png)
![img_2.png](Снимок%20экрана%202025-12-16%20160057.png)
![img_3.png](Снимок%20экрана%202025-12-16%20160432.png)

---

### Ошибка 4 — перепутанные аргументы или поля объекта

**Место:** `main.py`, функция `main()`, строка 16

**Симптом:**
При передаче двух аргументов командной строки программа использует неправильные значения для `steps` и `seed`. Второй аргумент присваивается переменной `steps` вместо `seed`.

**Как воспроизвести:**
```bash
python main.py 10 5
```

**Ожидаемое поведение:**
- `steps = 10`
- `seed = 5`

**Фактическое поведение:**
- `steps = 5`
- `seed = None`

**Отладка:**
Установлен breakpoint на строке 19: `steps = int(sys.argv[2])`.

При наличии двух аргументов:
```python
sys.argv = ['main.py', '10', '5']
```

**Первый вызов:**
```python
steps = int(sys.argv[1]) -> steps = 10
```

**Второй вызов:**
```python
steps = int(sys.argv[2]) -> steps = 5
```

Переменная `seed` остается `None`.

**Причина:**
Второй аргумент должен быть присвоен переменной `seed`, но ошибочно присваивается переменной `steps`. Это перепутывание аргументов приводит к тому, что значение `steps` перезаписывается, а `seed` остается неопределенным.

**Исправление:**
```python
# Было:
if len(sys.argv) > 2:
    try:
        steps = int(sys.argv[2])  
    except ValueError:
        print(f"Некорректный ввод seed: {sys.argv[2]}")
        return

# Стало:
if len(sys.argv) > 2:
    try:
        seed = int(sys.argv[2])   
    except ValueError:
        print(f"Некорректный ввод seed: {sys.argv[2]}")
        return
```

**Проверка:**
Поведение симуляции соответствует ожидаемому.

**Доказательства:**

![img_1.png](Снимок%20экрана%202025-12-18%20194453.png)
![img_2.png](Снимок%20экрана%202025-12-18%20194828.png)

---

### Ошибка 5 — перехват слишком общего исключения

**Место:** `src/commands/cat.py`, функция `cat_command`

**Симптом:**
При попытке чтения файла в различных ошибочных ситуациях пользователь всегда получает одно и то же неинформативное сообщение "Ошибка при чтении файла", независимо от реальной причины проблемы.

**Как воспроизвести:**
1. Запустить `python main.py`
2. В появившийся симулятор терминала ввести какой-либо вариант запроса:

**1. Несуществующий файл:**
```bash
cat meow.txt
```

**2. Директория вместо файла:**
```bash
cat /path/to/directory
```

**3. Бинарный файл:**
```bash
cat image.jpg
```

**4. Нет прав доступа:**
```bash
cat /root/secret_file.txt
```

**Отладка:**
Установить breakpoint на строке 18. Запустить с несуществующим файлом. В отладчике видно, что исключение `FileNotFoundError` перехватывается общим обработчиком.

**Причина:**
Использование слишком общего перехвата исключений `except Exception:` скрывает конкретные типы ошибок, что затрудняет диагностику проблем.

**Исправление:**
```python
# Было:
try:
    with open(filename, 'r', encoding='utf-8') as file:
        content = file.read()
        return content
except Exception:
    raise Exception("Ошибка при чтении файла.")

# Стало:
if not os.path.exists(filename):
    raise FileNotFoundError("Не удается найти указанный файл.")

if os.path.isdir(filename):
    raise IsADirectoryError("Отказано в доступе.")

try:
    with open(filename, 'r', encoding='utf-8') as file:
        content = file.read()
        return content
except UnicodeDecodeError:
    raise ValueError(f"Файл '{filename}' не является текстовым файлом.")
except PermissionError:
    raise PermissionError(f"Нет доступа к файлу '{filename}'.")
except Exception:
    raise Exception("Ошибка при чтении файла.")
```

**Проверка:**
Поведение симуляции соответствует ожидаемому.

**Доказательства:**
![img_1.png](Снимок%20экрана%202025-12-18%20225307.png)
![img_2.png](Снимок%20экрана%202025-12-18%20225134.png)
